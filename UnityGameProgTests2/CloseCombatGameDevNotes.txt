Close Combat Game Dev Notes



The engine chosen will be Unity 2018.4.15f1, as it supports multi-threading and
was the last Unity version before the company tried to push its own short-sighted
cloud solution onto every project.

Furthermore, Unity was the engine used for DUSK, and to great effect.


For the game, the following default build changes were made:


Edit->Project Settings->Editor->Unity Remote->Compression: PNG, Resolution:
Downsize, Joystick Source: Local

Edit->Project Settings->Time->Time-Maximum Allowed Timestep: 0.333333

Edit->Project Settings->Quality->Rendering->Pixel Light Count: 4

Edit->Project Settings->Quality->Rendering->Anti Aliasing: 2x Multi Sampling

Edit->Project Settings->Quality->Other->V-Sync Count: Don't Sync
(This was to, ideally, disable V-Sync. Will need to A/B compare later. Also,
seriously consider disabling Anti-Aliasing to make the game look more like a 6th
gen, PS2 game a la Urban Reign, especially in the name of efficient performance)


TO DO:


- Go on Stack Overflow and ask about whether it's more memory efficient to have
enemy functions exist in a manager class or in the enemy class itself.

- Go on Stack Overflow and/or the Unity forums and ask how to make objects
horizontally orbit one another using 3D Rigidbodies

- Go on Stack Overflow and ask for health bar creation tips, particularly to
solve the scaling issues occurring

- Go on Stack Overflow and ask if setting DTOs to null and calling the Garbage
Collector before and after truly frees up memory, does nothing, or actually
causes leaks and memory fragmentation. Mention how nulling certain objects still
makes them modifiable, since they're still in the Hierarchy.

- Go on Stack Overflow and/or the Unity forums and ask how to make the game look
like a PS2 one

- Review past notes for Collision, particularly Stolken's

- Cross-reference project's development with the Souls like

- Create Itch.IO page

- ALWAYS PROFILE, NEVER PRE-OPTIMIZE

- Create a basic Health System, with deaths for the Player and Enemy and meters
that effectively create win and loss states. Use the UI system to be able to
restart, use JSON for starting positions and other relevant data.

To that end, some facts to remember:

The MeterBackdrop.png file is 20 pixels by 20 pixels. The base width and height
of any meter is 222 pixels wide and 24 pixels tall, to accommodate extra space so
the meters look nice when they're empty.

RawImage files are used since they directly use Textures. The texture data is as
follows for MeterBackdrop.png:

15 pixels from the screen borders

Top-Left Anchor

Pos X: 20

Pos Y: -20

Pos Z: 0

Width: 20

Height: 20

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X and Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Color: Default, full 255

Raycast Target: True (May change)


The texture data is as follows for MeterBackdropBaseLength.png:

10 squares each, with a Width and Height of 20 pixels

15 pixels from the screen borders

Top-Left Anchor

Pos X: 122

Pos Y: -20

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X and Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Color: Default, full 255

Raycast Target: True (May change)


There are still some imprecisions, likely because the texture size is not a power
of 2 or a multiple of 4 in terms of pixel width and height, but the results are
good enough for now: The texture is clean with no filtering, and the dividers
look even enough. Naturally, this can change in time, and what likely should
happen anyway is for there to be 3 parts to the Meter backdrop: Start, Middle
(Which can increase in-game via upgrades), and End, all of which would be Powers
of 2 and Multiples of 4 for maximum efficiency and capabilities, meaning they
will likely be 32x32.

MeterBackdropBaseLengthAlt2 with BaseLength's RawImage values appears to be the
most optimal combination for the time being. It is truly good enough now, and
thus it is time to move on (For now).


POTENTIAL RGB VALUES FOR THE METERS AS FOLLOWS (NOTE: All should feel as though
they have the same shading for the sake of consistency):

Health: (234, 0, 23), (186, 0, 26), (186, 0, 0) (NOTE: When HP is lost, there
should be a meter indicating how much of it was lost. Specifically, it should be
the same shade as the lost HP meter found in Dark Souls 1)

Stamina: (195, 195, 0), (184, 186, 0)

Defense: (0, 92, 186)

Grip: (0, 186, 53)


NOTE: When it comes to Rect Transform components for RawImages, such as for the
meters, the origins are known as Pivots, and they operate based off of
tenths-place decimals of how much a percentage through the image the origin, or
Pivot, is located, meaning if the Pivot's X and Y are both 0.5, that means the
origin is right in the middle of the image, or half-way through - 50%. Thus, it
is recommended to set the Pivot X value to 0 for meters so that they scale on the
X axis from the side rather than the center and thus always forcing a
re-adjustment via code.


At any rate, the meter backdrops have been made, along with the actual
rectangles. Their RawImage data values are as follows (This assumes that the
actual meters are children of their respective backdrops):


Health Meter:


Top-Left Anchor

Pos X: 2

Pos Y: -12

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: None (May change)

Color: (186, 0, 0)

Raycast Target: False (May change)


Stamina Meter:


Top-Left Anchor

Pos X: 2

Pos Y: -12.25

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: None (May change)

Color: (184, 186, 0)

Raycast Target: False (May change)


Defense Meter:


Top-Left Anchor

Pos X: 2

Pos Y: -12.25

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: None (May change)

Color: (0, 92, 186)

Raycast Target: False (May change)


Health Meter Backdrop:


Top-Left Anchor

Pos X: 10

Pos Y: -20

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBackdropBaseLengthAlt2.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Stamina Meter Backdrop:


Top-Left Anchor

Pos X: 10

Pos Y: -55

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBackdropBaseLengthAlt2.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Defense Meter Backdrop:


Top-Left Anchor

Pos X: 10

Pos Y: -90

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBackdropBaseLengthAlt2.png

Color: (255, 255, 255)

Raycast Target: False (May change)


UPDATE:


Finally made layered meters. Render Order in Unity's Canvas system is based off
of the Game Object order - those that are higher up on the list get rendered
first.

Each meter is comprised of 3 layers: The Background, which will serve as the
final BG for when a meter is emptied; the Meter itself, representing the count of
something; the Meter Cover, comprised of the meter shell and dividing lines.

This naturally required some additional finessing. While this is a fine baseline
for how the meters should overall look and behave, this may still not be the
final version. In all likelihood, the final version will have the 3
aforementioned meter layers split between beginning, middle, and end segments.

The results are as follows:


Health Meter Root Object:


Top-Left Anchor

Pos X: 10

Pos Y: -20

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: None

Color: (255, 255, 255, Alpha is 0)

Raycast Target: False (May change)


Health Meter BG:


Top-Left Anchor

Pos X: 2

Pos Y: -12

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBGBaseLength.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Health Meter Bar:


Top-Left Anchor

Pos X: 2

Pos Y: -12

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterHPBaseLength.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Health Meter Cover:


Top-Left Anchor

Pos X: 0

Pos Y: -12

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBaseLengthCover.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Stamina Meter Root Object:


Top-Left Anchor

Pos X: 10

Pos Y: -55

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: None

Color: (255, 255, 255, Alpha is 0)

Raycast Target: False (May change)


Stamina Meter BG:


Top-Left Anchor

Pos X: 2

Pos Y: -12

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBGBaseLength.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Stamina Meter Bar:


Top-Left Anchor

Pos X: 2

Pos Y: -12.25

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterSTMNABaseLength.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Stamina Meter Cover:


Top-Left Anchor

Pos X: 0

Pos Y: -12

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBaseLengthCover.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Defense Meter Root Object:


Top-Left Anchor

Pos X: 10

Pos Y: -90

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: None

Color: (255, 255, 255, Alpha is 0)

Raycast Target: False (May change)


Defense Meter BG:


Top-Left Anchor

Pos X: 2

Pos Y: -12

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBGBaseLength.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Defense Meter Bar:


Top-Left Anchor

Pos X: 2

Pos Y: -12.25

Pos Z: 0

Width: 220

Height: 19

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterDFNSEBaseLength.png

Color: (255, 255, 255)

Raycast Target: False (May change)


Defense Meter Cover:


Top-Left Anchor

Pos X: 0

Pos Y: -12

Pos Z: 0

Width: 224

Height: 24

Min X Anchor: 0

Min Y Anchor: 1

Max X Anchor: 0

Max Y Anchor: 1

Pivot X: 0

Pivot Y: 0.5

Rotation X, Y, Z: 0

Scale X, Y, Z: 1

Texture: MeterBaseLengthCover.png

Color: (255, 255, 255)

Raycast Target: False (May change)


UPDATE, 3/24/2023:


Began JSON parsing implementation. According to preliminary results in another
.sln, it should work, especially now that Newtonsoft.JSON appears to have been
successfully implemented into the Unity .sln.

Since then, the values of the meters have been copy-pasted and generalized into
common, shared sets in preliminary JSON files.

Now, the key task is to format them into Unity's actual values found under the
hood, which is achieved via a data reading debugging class.

Of note is that the RGBA values of RawImage objects are not integer values a la
0-255 RGB format, but float percentages from 0 to 1 - something that must be
factored into the final JSON format of these files.

Similarly, the RectTransform dimension values are proving to be quite
troublesome, as the raw values in the inspector are not what is returned in the
data reading class. These values are likely influenced by anchors, and possibly
pivots as well - more analysis required.

Based off of the analysis, it appears that the inspector-specified values are
found in RectTransform.AnchoredPosition, which corroborates the earlier theory of
the Anchors influencing the position and interpretation of RectTransform's
dimensions. The Width and Height are still found within the rect object,
however.

This is more or less how you change the RectTransform's inspector x, y, w, and h
values, and will be necessary for implementing final data parsing from the JSON
files so that there's no great dependency on the inspector. This is what will
have to occur by forcing JSON-stemming values onto existing objects, or creating
new objects entirely and setting their values onto the existing ones, either
through cloning or direct setting in the Unity Start() function:

rTnsfrm.anchoredPosition = new Vector2(0, -10);
rTnsfrm.sizeDelta = new Vector2(3, 30);

UPDATE, 4/6/2023:


Unfortunately, code itself won't solve the current issues with the health meter.

For one thing, the appearance changes too much when the width is too low, as
tested via the ValReader debug script that changes the sizeDelta as described
above.

Second, there appear to be scaling issues overall, as the meters are still not to
the power of 2 or multiples of 4, despite best efforts, and even though the
dimensions for each cell along the dividers are equal, they appear to be anything
but in the screenshots, and required different values to get
Photoshop-approximate sizes within Unity via the RectTransform component.

Dimension comparisons are as follows:


Meter Dimensions, Photoshop:

Texture Name: MeterBGBaseLength.png, MeterHPBaseLength.png
Width and Height: 178, 16
Width and Height, Individual Cells: 16, 16

Texture Name: MeterBaseLengthCover.png
Width and Height: 182, 20


Meter Dimensions, Unity RectTransform:

Texture Name: MeterBGBaseLength.png, MeterHPBaseLength.png
Width and Height: 220, 19

Texture Name: MeterBaseLengthCover.png
Width and Height: 224, 24


Meter Dimensions, Screenshot:

Texture Name: MeterBGBaseLength.png, MeterHPBaseLength.png
Width and Height: 376, 33
Width and Height, Individual Cells: 34, 33

Texture Name: MeterBaseLengthCover.png
Width and Height: 384, 41


Attempted several variants, and each one was worse than the previous values. Will
need to discuss issues on Stack Overflow to get a resolution. Otherwise, shelve
for now.


UPDATE, 4/7/2023:


JSON parsing is working, Data Sheet classes complete. Brief tests indicated that
it is possible to make entire classes based off of a certain JSON property that
won't be considered an extra, redundant layer - in other words, it is possible
to have a class instance in another class representating a data sheet whose
entire contents are 1 class instance of something rather generic and universal,
like a size-3 floating point array, and have this extra class instance sport the
JSOn Property Name of "rot" for rotation. In practical terms, it is thus possible
for sub-objects in code to represent objects at the same level and NOT be
considered actual sub-objects, but just the same level, allowing for redundancy
and possibly more concrete types. This is unnecessary - for now - unless the
object can exist in 2 rather different domains, has a wide-enough range of
applications (Like color), and its deepest class code contents do not make it
obvious what it is, like color, which is comprised solely of a size-4 floating
point array whose values should only range from 0 to 1.

While the parsing is complete, it is still necessary to take the parsed data
sheet and have its values be set on the necessary game objects. This will be the
next step.


As a reminder, the development itinerary is as follows:

1. Data Sheet Parsing and Setting

2. Implementing Win and Loss States (Comprised of pressing buttons that set HP
values to 0, and have certain text and buttons pop up, followed by the restarting
of necessary positions, which will involve reading more data for things like
player and enemy starting position)

3. Complete, basic movement based off of RigidBody.velocity (Moving forward,
orbiting, combined movement for both; consider using the Character Controller
instead if RigidBody.velocity doesn't work out, for whatever reason)

4. Character model and animation setting


UPDATE, 4/7/2023:


Data Sheet Parsing and Setting is complete - everything is properly read and set.

Furthermore, Cleanup processes involving manual garbage collection calls and
nulling out no-longer used objects were implemented. These processes may need to
be modified for final release, in case nulling out said objects proves to be too
troublesome when the Scene Inspector is not a factor, although preliminary tests
indicate that this may not be a problem in the future; TBD.

Now, it is time to implement Win and Loss States as described above, in addition
to the clerical tasks related to Stack Overflow and Itch.IO page creation.


UPDATE, 4/20/2023:


Win and Loss State construction has begun - pressing H makes the Player lose and
the Enemy win, while pressing J does the opposite. At time of writing, all that
occurs is that the loser's HP is set to 0 and some Debug text is printed, with
said text declaring the Winner and Loser.

Additionally, finally go on Stack Overflow and the Unity forums and ask the
questions at the top.


DONE:


- Implement the textures, scripts and settings from the earlier Unity Test
Project, UnityGameProgTests

- Ensure that the Update Rate is 60 UPS/FPS