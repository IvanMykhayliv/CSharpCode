///Enemy generator script by Joe Cole ☻
using UnityEngine;
using System.Collections;
using UnityEngine.SceneManagement;

public class EnemyGenerator : MonoBehaviour {

    public delegate void OnEnemyCreatedHandler(GameObject enemy);
    public static event OnEnemyCreatedHandler OnEnemyCreated;
    public delegate void WaveHandler();
    public static event WaveHandler WaveEnd;
    public static event WaveHandler WaveStart;
     ///< controls the scene switch condition, increased by the game's difficulty in start()
    
    public GameObject WinScreen;

    /// <summary>
    /// the following are the enemy types that can be spawned by the generator
    /// </summary>
    public GameObject EnemyNormal;
    public GameObject EnemyFast;
    public GameObject EnemyTank;
    public GameObject EnemyBoss;
    public GameObject EnemySplitter;

    /// <summary>
    /// spawn speed variables
    /// </summary>
    int normalSpawnDelay = 60; ///< this values is the normal frequency of spawns
    int zergSpawnDelay = 10; ///< not premitted to be zero, for the zerg rush wave 
    int nextSpawnDelay; ///< has either of the above two values depedning on the wave frequency

    public static int Waves;
    public int WinWaves = 40;
    public string WinLevel;
    public int bossWaveNum = 10; ///< triggers the boss wave
    public int fodderWaveNum = 3; ///< triggers the fodder wave
    public int swarmWaveNum = 5; ///< triggers both the zerg rush and more enemies to spawn
    public int SpecialSpawn = 5; ///< causes special enemies to show up, decreased by the game's difficulty in start()
    public int FastSpawn = 2; ///< controls the frequency of fast enemies under normal circumstances
    public int TankSpawn = 3; ///< controls the frequency of tankier enemies
    public int swarm = 2; ///< directly correleated with the length of waves, increased by the game's difficulty in start()
    public float EnemiesSpawned; ///< determines when to stop spawning, by comparing this against Waves in EnemyTimer()
    public bool waveStarted; ///< prevents unusual behaviour caused by abruptly ending a wave and starting the next, near universally true
    public static bool waveActive { get; private set; } ///< as the above is almost always true 

    /// <summary>
    /// audio
    /// </summary>
    public AudioClip BossMusic;
    public AudioClip RegularMusic;
    public GameObject BGM;
    private AudioSource source;

    /// <summary>
    /// this runs when the script is created
    /// uses GameController.Difficulty as I will not know the difficulty until runtime
    /// everything else is generic initialization
    /// </summary>
	void Start () {
        nextSpawnDelay = normalSpawnDelay;
        waveActive = false;
        StartCoroutine(EnemyTimer());
        EnemiesSpawned = 0;
        Waves = 1;
        swarm += GameController.Difficulty;
        SpecialSpawn -= GameController.Difficulty;
        //WinWaves *= (1 + GameController.Difficulty);
        waveStarted = true;
        
        source = BGM.GetComponent<AudioSource>();
        source.clip = RegularMusic;
        source.Play();
	}

    void Update()
    {
        if (!source.isPlaying)
            source.Play();
        if (Waves >= WinWaves)
        {
            if ((GameObject.FindWithTag("Enemy") == null))
            {
                SceneManager.LoadScene(WinLevel);
                GameController.Win = true;
                WinScreen.SetActive(true);
            }
        }
    }

    ///<description>
    /// this functions uses data to connect the configuration with enemies generated
    /// is for keeping the enemy generation function in one place so that changes are propagated properly
    ///</descrition>
    void CreateEnemy(GameObject EnemyType, int level, float haste, float durability)
    {
        GameObject enemy = Instantiate(EnemyType);
        if (OnEnemyCreated != null)
        {
            OnEnemyCreated(enemy);
        }
        enemy.GetComponent<EnemyController>().EnemyStats(level, haste, durability);
        /// If you want micah as a boss to be generated by this file add another if satement of the type below
        if (EnemyType == EnemySplitter)
            //enemy.EnemyType = EnemyType;
            enemy.GetComponent<EnemyController>().enemyType = global::EnemyType.Split;
        enemy.transform.localPosition = new Vector3(transform.localPosition.x, transform.localPosition.y, transform.localPosition.z);
    }

    ///<description>
    ///this function configures the enemies
    ///</descrition>
    void Spawn()
    {
        float carry;
        
        /// wave speed, this if statement causes the dedicated swarm wave to spawn more enemies
        if ((Waves % swarmWaveNum) == 0)
        {
            
            // swarm wave
            EnemiesSpawned += (1f / (swarm));
            carry = 0f;
        }
        else
        {
            EnemiesSpawned += (2f / (swarm));
            carry = .5f;
        }

        /// each case depicts a wave type
        if ((Waves % bossWaveNum) == 0 && !waveStarted){
            /// creates the boss enemy on first spawn of the boss wave
            CreateEnemy(EnemyBoss, Waves, 0, 1);
        }
        else if ((Waves % fodderWaveNum) == 0)
        {
            /// runs the fodder wave
            if ((int)EnemiesSpawned % TankSpawn == 0)
            {
                CreateEnemy(EnemyTank, Waves, 0, 1);
            }
            else
            {
                CreateEnemy(EnemySplitter, Waves, 1, 1);
            }
        }
        else if ((int)(EnemiesSpawned) % SpecialSpawn == 0)
        {
            /// causes special enemies to spawn on normal waves
            if ((int)EnemiesSpawned % (FastSpawn * TankSpawn) == 0)
            {
                CreateEnemy(EnemySplitter, Waves, .25f, carry * 1.5f);
            }
            else if ((int)EnemiesSpawned % TankSpawn == 0)
            {
                CreateEnemy(EnemyTank, Waves, 0, carry * .5f);
            }
            else if ((int)EnemiesSpawned % FastSpawn == 0)
            {
                CreateEnemy(EnemyFast, Waves, 1, carry * 1.5f);
            }
            else
            {
                CreateEnemy(EnemyNormal, Waves * 2, .5f, carry);
            }
        }else{
            /// this creates the regular enemies
            CreateEnemy(EnemyNormal, Waves, .5f, carry);
        }
    }

    /// <summary>
    /// this IEnumerator controls the enemy spawn frequency based of the nextSpawnDelay variable
    
    /// </summary>
    IEnumerator EnemyTimer()
    {
        while (true)
        {
            /// as a reminder nextSpawnDelay cannot be 0 
            for (float i = 0f; i < nextSpawnDelay; i += GameController.EnemySpeed)
            {
                while (Time.timeScale == 0) { yield return 0; }
                yield return 0;
            }
            /// if the wave isn't over spawn() an enemy
            if (Mathf.Sqrt(EnemiesSpawned) < (Waves + 2))
            {
                Spawn();
                if (!waveActive)
                    waveActive = true;
            }
            else
            {
                /// the store needs to know when the wave is over 
                if (waveActive && GameObject.FindGameObjectsWithTag("Enemy").Length == 0)
                {
                    waveActive = false;
                    if (WaveEnd != null)
                    {
                        WaveEnd();
                    }
                }
            }
        }
    }

	public void NextWave()
    {
        Waves++;
        ///this is called by a button thats always active
        ///however this function does inadvertant things in the middle of the wave
        if ((GameObject.FindWithTag("Enemy") == null)) //&& waveStarted)
        {
            source.Stop();

            ///sets the frequency of the next wave
            if ((Waves % swarmWaveNum) == 0){
                nextSpawnDelay = zergSpawnDelay;
                Debug.Log("RUSH");
            } else {
                nextSpawnDelay = normalSpawnDelay;
            }

            /// this sets up the next wave
            waveStarted = false;
            EnemiesSpawned = 0;
            
            Debug.Log(Waves);

            ///sets the wave's music
            if (Waves % bossWaveNum == 0)
                source.clip = BossMusic;
            else
                source.clip = RegularMusic;
            source.Play();
        }
	}

}